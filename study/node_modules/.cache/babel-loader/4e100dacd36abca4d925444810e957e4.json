{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport functionTimeout, { isTimeoutError } from 'function-timeout';\nimport timeSpan from 'time-span';\nimport cloneRegexp from 'clone-regexp'; // TODO: Use `structuredClone` instead when targeting Node.js 18.\n\nconst resultToMatch = result => ({\n  match: result[0],\n  index: result.index,\n  groups: result.slice(1),\n  namedGroups: result.groups ?? {},\n  input: result.input\n});\n\nexport function isMatch(regex, string, {\n  timeout\n} = {}) {\n  try {\n    return functionTimeout(() => cloneRegexp(regex).test(string), {\n      timeout\n    })();\n  } catch (error) {\n    if (isTimeoutError(error)) {\n      return false;\n    }\n\n    throw error;\n  }\n}\nexport function firstMatch(regex, string, {\n  timeout\n} = {}) {\n  try {\n    const result = functionTimeout(() => cloneRegexp(regex).exec(string), {\n      timeout\n    })();\n\n    if (result === null) {\n      return;\n    }\n\n    return resultToMatch(result);\n  } catch (error) {\n    if (isTimeoutError(error)) {\n      return;\n    }\n\n    throw error;\n  }\n}\nexport function matches(regex, string, {\n  timeout = Number.POSITIVE_INFINITY,\n  matchTimeout = Number.POSITIVE_INFINITY\n} = {}) {\n  if (!regex.global) {\n    throw new Error('The regex must have the global flag, otherwise, use `firstMatch()` instead');\n  }\n\n  return {\n    *[Symbol.iterator]() {\n      try {\n        const matches = string.matchAll(regex); // The regex is only executed when iterated over.\n\n        while (true) {\n          const nextMatch = functionTimeout(() => matches.next(), {\n            timeout: timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY ? Math.min(timeout, matchTimeout) : undefined\n          }); // `matches.next` must be called within an arrow function so that it doesn't loose its context.\n\n          const end = timeSpan();\n          const {\n            value,\n            done\n          } = nextMatch();\n          timeout -= Math.ceil(end());\n\n          if (done) {\n            break;\n          }\n\n          yield resultToMatch(value);\n        }\n      } catch (error) {\n        if (!isTimeoutError(error)) {\n          throw error;\n        }\n      }\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/madukadu/Github/Study Abroad Public Access/Study-Abroad/study/node_modules/super-regex/index.js"],"names":["functionTimeout","isTimeoutError","timeSpan","cloneRegexp","resultToMatch","result","match","index","groups","slice","namedGroups","input","isMatch","regex","string","timeout","test","error","firstMatch","exec","matches","Number","POSITIVE_INFINITY","matchTimeout","global","Error","Symbol","iterator","matchAll","nextMatch","next","Math","min","undefined","end","value","done","ceil"],"mappings":"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","sourcesContent":["import functionTimeout, {isTimeoutError} from 'function-timeout';\nimport timeSpan from 'time-span';\nimport cloneRegexp from 'clone-regexp'; // TODO: Use `structuredClone` instead when targeting Node.js 18.\n\nconst resultToMatch = result => ({\n\tmatch: result[0],\n\tindex: result.index,\n\tgroups: result.slice(1),\n\tnamedGroups: result.groups ?? {},\n\tinput: result.input,\n});\n\nexport function isMatch(regex, string, {timeout} = {}) {\n\ttry {\n\t\treturn functionTimeout(() => cloneRegexp(regex).test(string), {timeout})();\n\t} catch (error) {\n\t\tif (isTimeoutError(error)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexport function firstMatch(regex, string, {timeout} = {}) {\n\ttry {\n\t\tconst result = functionTimeout(() => cloneRegexp(regex).exec(string), {timeout})();\n\n\t\tif (result === null) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn resultToMatch(result);\n\t} catch (error) {\n\t\tif (isTimeoutError(error)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexport function matches(regex, string, {timeout = Number.POSITIVE_INFINITY, matchTimeout = Number.POSITIVE_INFINITY} = {}) {\n\tif (!regex.global) {\n\t\tthrow new Error('The regex must have the global flag, otherwise, use `firstMatch()` instead');\n\t}\n\n\treturn {\n\t\t* [Symbol.iterator]() {\n\t\t\ttry {\n\t\t\t\tconst matches = string.matchAll(regex); // The regex is only executed when iterated over.\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst nextMatch = functionTimeout(() => matches.next(), {timeout: (timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY) ? Math.min(timeout, matchTimeout) : undefined}); // `matches.next` must be called within an arrow function so that it doesn't loose its context.\n\n\t\t\t\t\tconst end = timeSpan();\n\t\t\t\t\tconst {value, done} = nextMatch();\n\t\t\t\t\ttimeout -= Math.ceil(end());\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tyield resultToMatch(value);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!isTimeoutError(error)) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}